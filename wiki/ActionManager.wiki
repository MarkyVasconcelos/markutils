#summary ActionManager, a new way to call listeners and methods for buttons.
#labels Phase-Implementation

= Introduction =

This Manager configure your JButtons annotateds with @Action to call the respective informed parameter.

= Details =

This Annotation has two attributes.

String method() default “” – When pressed the button will call the method with this name, the method should not has parameters and can has any visibility modifier.

Class<? extends ActionListener> listener() default ActionListener.class – When pressed the manager create a instance of this class and call its actionPerformed method. (Actually this only work if the class is a inner class, i'll fix soon)

You only have to set one theses parameters, if both are set, only the method will be resolved.

For this example I used the same example as the Binder.

Consider this Person class for the example:
{{{
public class Person {
	private String name;
	private int age;
	private boolean live;// no ideas for a boolean attr :P
	public void printAttrs() {
		System.out.println("Name: " + getName());
		System.out.println("Age: " + getAge());
		System.out.println("Live?: " + isLive());
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public int getAge() {return age;}
	public void setAge(int age) {this.age = age;}
	public boolean isLive() {return live;}
	public void setLive(boolean live) {this.live = live;}
}
}}}

And the Form.
{{{
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;

import mark.utils.awt.ann.Action;
import mark.utils.awt.ann.ActionManager;
import mark.utils.bind.Binder;
import mark.utils.bind.annotation.AnnotatedBinder;
import mark.utils.bind.annotation.Bindable;
import mark.utils.bind.annotation.Form;

@Form(Person.class)
public class PersonForm extends JFrame {
	@Bindable(field = "name")
	private JTextField name;
	@Bindable(field = "age", formatter = IntFormatter.class)
	private JTextField age;
	@Bindable(field = "live")
	private JCheckBox live;
	private Binder binder;
	@Action(method = "add")
	private JButton add;
	@Action(listener = Listener.class)
	private JButton load;

	public PersonForm() {
		super("PessoaForm");
		name = new JTextField(20);
		age = new JTextField(20);
		live = new JCheckBox("Live?");
		add = new JButton("Add");
		load = new JButton("Load");
		setLayout(new GridLayout(5, 2));
		add(new JLabel("name:"));
		add(name);
		add(new JLabel("Age:"));
		add(age);
		add(new JLabel());// Empty comp for the grid layout
		add(live);
		add(add);
		add(load);
		pack();
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setLocationRelativeTo(null);

		new ActionManager(this);
		binder = new AnnotatedBinder(this);
	}

	public static void main(String[] args) {
		new PersonForm().setVisible(true);
	}

	// Listener for the button load
	private class Listener implements ActionListener {
		@Override
		public void actionPerformed(ActionEvent e) {
			Person person = new Person();
			person.setName("Marky");
			person.setAge(18);
			person.setLive(true);
			binder.updateView(person);
		}
	}

	// Method for the button add
	private void add() {
		Person person = new Person();
		binder.updateModel(person);
		person.printAttrs();
	}

	// IntFormatter to convert a String to int
	public static class IntFormatter implements mark.utils.bean.Formatter {
		public Object format(Object obj) {
			Integer d = (Integer) obj;
			return d.toString();
		}

		public Object parse(Object obj) {
			return Integer.valueOf(Integer.parseInt((String) obj));
		}

		public String getName() {
			return "int";
		}
	}
}

}}}

The JButton add should call method add and the JButton create a istance of Listener and call its actionPerformed method.

It's needed to create a new instance of ActionManager to the @Action annotations work.(Soon i'll create a general manager to make easier create all the managers of the project)


Sometimes, a JButton can have more than a action. For this, just use @ActionSequence instead of @Action and pass a @Action vector as parameter of the desired sequence. Something like.

{{{
@ActionSequence({@Action(method="openSession"),@Action(listener=AddListener.class),@Action(method="closeSession")})
private JButton add;
}}}

In this case when add is pressed:
1° - The openSession method is called

2° - The actionPerformed of the AddListener class is called

3° - The closeSession method is called.